/**
* This file is generated by 'protoapi'
* The file contains helper functions that would be used in generated api file, usually in './api.ts' or './xxxService.ts'
* The generated code is written in TypeScript
* -------------------------------------------
* 该文件生成于protoapi
* 文件包含一些函数协助生成的前端调用API
* 文件内代码使用TypeScript
*/
import { CommonError, GenericError, AuthError, ValidateError, BindError } from './AppServiceObjs'
export type CommonErrorType = GenericError | AuthError | BindError | ValidateError
/**
 * Defined Http Code for response handling
 */
export enum httpCode {
    DEFAULT = 0,
    NORMAL = 200,
    BIZ_ERROR = 400,
    COMMON_ERROR = 420,
    INTERNAL_ERROR = 500,
}
/**
 *
 * @param {CommonError} commonErr the error object
 */
export function mapCommonErrorType(commonErr: CommonError): CommonErrorType | null {
    for (const key in commonErr) {
        if (!!commonErr[key]) {
            const err = Object.assign({ kind: key }, commonErr[key])
            const commonErrTypes = ['genericError', 'authError', 'validateError', 'bindError']
            if (commonErrTypes.includes(key)) {
                return err
            }
        }
    }
    return null
}

/**
 *
 * @param val a string
 * @returns an encoded string that can be append to api url
 */
export function encode(val: string): string {
    return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 * @param url : the base url for the service
 * @param params : the request object. e.g. for HelloRequest would be the object of type HelloRequest
 * @returns: returns a full Url string - for GET by key/value pairs
 * @example:
 * baseUrl = "http://localhost:8080"
 * arg = {name: "wengwei", nick: "wentian"}
 * returns => http://localhost:8080?name="wengwei"&nick="wentian"
 */
export function generateQueryUrl<T>(url: string, params: T): string {
    if (!params) {
        return url;
    }

    let parts: string[] = [];


    for (let key in params) {
        let val;
        if (Object.prototype.hasOwnProperty(key)) {
            val = params[key];
        }

        if (val === null || typeof val === 'undefined') {
            return '';
        }

        let k, vals;
        // if is array
        if (val.toString() === '[object Array]') {
            k = key + '[]';
        } else {
            k = key
            vals = [val];
        }

        vals.forEach(v => {
            // if is date
            if (v.toString() === '[object File]') {
                v = v.toISOString();
                // if is object
            } else if (typeof v === 'object') {
                v = JSON.stringify(v);
            }
            parts.push(encode(k) + '=' + encode(v))
        });
    }
    let serializedParams = parts.join('&');

    if (serializedParams) {
        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }
    return url
}

/**
 *
 * @param url the base url for the service
 * @param serviceName the service name
 * @param functionName the function name
 * @example
 * baseUrl = "http://localhost:8080"
 * serviceName = "HelloService"
 * functionName = "SayHello"
 * returns => http://localhost:8080/HelloService.SayHello
 */
export function generateUrl<T>(url: string, serviceName: string, functionName: string): string {
    return url + "/" + serviceName + "." + functionName;
}

/**
 *
 * @param {response} response the error response
 */
export async function errorHandling(error): Promise<any> {
    if(!error) {
        return error
    }
    if (!!error.data && typeof error.data === 'object') {
        if (error.data.message) {
            error.message = error.data.message
        }
        switch (error.status) {
            case httpCode.BIZ_ERROR:
                return error;
            case httpCode.COMMON_ERROR:
                const returnErr = (() => {
                    try {
                        return mapCommonErrorType(error.data);
                    } catch (e) {
                        return undefined;
                    }
                })()
                if(!returnErr){
                    return error;
                }
                return ({...error, ...returnErr});
        }
    }
    return error;
}